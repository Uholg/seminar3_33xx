# *Инструкция по работе с Git*

## Что такое Git

**Git** — это система контроля версий (VCS), которая позволяет отслеживать и фиксировать изменения в коде: вы можете восстановить код в случае сбоя или откатить до более ранних версий. Каждая рабочая копия кода сама по себе является репозиторием, поэтому это удобный инструмент для взаимодействия нескольких разработчиков на одном проекте. Система позволяет всем разработчикам хранить историю изменений в полном объеме.

## Создание локального репозитория

Для того чтобы создать (инициализировать) локальный репозиторий необходимо в терминале, находясь в папке проекта выбрать команду:

    git init

## Проверка состояния репозитория

   Чтобы проверить состояние репозитория используют команду:

    git status

## Добавление изменений в индекс

 Чтобы добавить в индекс все новые, изменённые, удалённые файлы из текущей директории и её поддиректорий 
    
    git add .        
    
    
Чтобы добавить в индекс указанный файл (был изменён, был удалён или это новый файл), 

    git add text.txt  

Чтобы запустить интерактивную оболочку для добавления в индекс только выбранных файлов, 

    git add -i   

Чтобы показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании, необходима команда:

    git add -p        

## Удаление изменений из индекса

Чтобы убрать из индекса все добавленные в него изменения (в рабочей директории все изменения сохранятся, антипод git add), необходима команда:

    git reset 

Чтобы убрать из индекса изменения указанного файла (в рабочей директории изменения сохранятся), необходима команда:

    git reset readme.txt   

## Фиксация изменений в коммите

Команда _**git commit**_ откроет текстовый редактор для ввода сообщения коммита.
Также эта команда принимает несколько аргументов:

• 	**-m** позволяет написать сообщение вместе с командой, не открывая редактор. Например :

    git commit -m "Ошибка исправлена";

•	**-a** переносит все отслеживаемые файлы в область подготовленных файлов и включает их в коммит (позволяет пропустить git add перед коммитом). Например:
    
    git commit -a -m "Ошибка исправлена" 

•	**--amend** заменяет последний коммит новым изменённым коммитом, что бывает полезно, если вы неправильно набрали сообщение последнего коммита или забыли включить в него какие-то файлы.

## Как посмотреть коммиты

Для просмотра всех выполненных фиксаций можно воспользоваться историей коммитов. Она содержит сведения о каждом проведенном коммите проекта. Запросить ее можно при помощи команды:
    
    git log

В ней содержиться вся информация о каждом отдельном коммите, с указанием его хэша, автора, списка изменений и даты, когда они были сделаны. 

В команде могут быть использованы следующие аргументы:


* *git log master*          - показать коммиты в указанной ветке
* *git log -2*                - показать последние 2 коммита в активной ветке
* *git log --oneline* - показать коммиты в упрощенном виде, каждый коммит в одну строку
* *git log --all* - показать коммиты в полном виде


Отследить интересующие вас операции в списке изменений, можно по хэшу коммита, при помощи команды _**git show**_ :
    
    git show hash_commit

# Временное переключение на другой коммит

Чтобы переключиться на коммит с указанным хешем (переместить HEAD на указанный коммит, рабочую директорию вернуть к состоянию, на момент этого коммита) используется команда:

    git checkout b9533bb 

 Чтобы переключиться на коммит, на который указывает master (переместить HEAD на коммит, на который указывает master, рабочую директорию вернуть к состоянию на момент этого коммита) используется команда:

    git checkout master 

# Отслеживание изменений между коммитами

Чтобы посмотреть сами изменения, а не изменённые файлы, можно использовать следующие команды:
•	__*git diff*__ — сравнение рабочей директории с областью подготовленных файлов;
•	__*git diff --staged*__ — сравнение области подготовленных файлов с HEAD.

Если использовать аргумент <файл/папка>, то *diff* покажет изменения только для указанных файлов/папок, например __*git diff src/*__.

# Дополнительная информация

Команда git config --list выведет все поля и их значения из конфигурационного файла.

# Полезные ссылки 

*GitHub* — это служба размещения в Интернете репозиториев Git, которые используются для хранения содержимого docs.microsoft.com. В GitHub размещается основной репозиторий всех проектов.

Ссылка: [github](github.com "Ссылка на github")


## Работа с ветками 

*Ветка* - независимая последовательность коммитов в хронологическом порядке. В Git ветка является указателем на последний коммит в рассматриваемой ветке. После создания ветки уже новый указатель ссылается на текущий коммит.

Имя основной ветки Git-проекта по умолчанию — master (однако зачастую бывает main, например, в GitHub), она появляется сразу при инициализации репозитория. Эта ветка ничем не отличается от остальных и также ее можно переименовать, но по договоренности master принято считать главной веткой в проекте.

## Способы создания веток и переключения между ними

Чтобы добавить ветку используется команда: 

    git branch <Имя ветки>

После данной операции новая ветка создается, но вы по-прежнему находитесь в прежней ветке.

Чтобы переместиться на другую ветку используется команда:

    git checkout <Имя ветки>

Для того чтобы определить, где сейчас находится разработчик, Git использует специальный указатель HEAD, ссылающийся на текущую локальную ветку. В результате checkout HEAD переместится на иную ветку.

При создании новой ветки пользователю необходимо сразу же переключиться на нее. В таком случае можно использовать команду:


    git checkout branch <Имя новой ветки> 


## Флаги git checkout 

-b <Имя ветки> -  идентичен команде  git checkout branch


Если пользователю нужно получить список определенного множества веток, то тогда можно воспользоваться флагами:

-r — при использовании мы получим список удаленных веток,
-a — используя этот флаг, в выводе будут удаленные и локальные ветки.


## Слияние веток

Перенос изменений с одной ветки на другую выполняется с помощью команды:

    git merge <имя вливаемой ветки> 
    
Однако сливаемая ветка (ветка, у которой беруться изменения для «вливания» их в другую ветвь) никак не меняется и остается в прежнем состоянии. 

Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды - необходимо разрешить конфликт!

## Флаги git branch

-v - можно получить последний сохраненный коммит в каждой ветке.

—merged и —no-merged - можно отфильтровать полученную последовательность веток. 

То есть мы получим список ответвлений, которые уже были слиты, или, наоборот, ветки, которые еще не прошли через слияние с другими. 

 ## Флаги git merge

 Операция может привести к появлению конфликтов при попытке слить ветки. Это вызвано тем, что изменения удаляют или переписывают информацию в существующих файлах. При попытке некорректного слияния Git останавливает выполнение команды, чтобы вы могли разрешить конфликт.

Флаги для работы с конфликтами:

—*abort* — прерывает слияние и возвращает все к началу;
—*continue* — продолжает слияние после разрешения конфликта;

Решить конфликт можно двумя способами:

* Вручную разрешить файловый конфликт. Для этого нужно самим изменить файлы, с которыми возникли проблемы. Мы получим файлы такими, какими и представляли их при попытке слияния.

* Выбрать более подходящий файл, а от второго отказаться


## Переименование ветки

В процессе разработки могут возникнуть ситуации, когда человек хочет по-другому называть уже созданную ветку. Чтобы переименовать ветку выполняется команда:


    git branch -m <new name of branch>

Однако здесь нужно быть аккуратными, чтобы не перегрузить проект ненужными ветками. Если запушить переименованную ветку, то на сервере появится ветка с новым именем, но и ветка со старым названием тоже останется. Чтобы избежать такой проблемы, необходимо удалить ветку локально и на сервере.

—merged и —no-merged - можно отфильтровать полученную последовательность веток. То есть мы получим список ответвлений, которые уже были слиты, или, наоборот, ветки, которые еще не прошли через слияние с другими. 

## Удаление ветки

Удаление веток не такой простой процесс, как может показаться. Можно случайно удалить несохраненные изменения в исходном коде, что приведет к нежелательным последствиям. Поэтому здесь нужно действовать осторожно. Команда удаления ветки:

     git branch -d <name of branch>


## Удаленные репозитории

Для совместной работы над проектами Git требуются навыки управления удаленными репозиториями. Удаленные репозитории представляют собой версии проекта, хранимые в Интернете или где-то в сети. Их может быть несколько, и каждый в общем случае доступен вам только для чтения или же для чтения и записи. Вы должны уметь отправлять данные в удаленный репозиторий и извлекать их оттуда каждый раз, когда требуется обменяться результатами работы. 

## Отображение удаленных репозиториев 

Просмотр уже настроенных удаленных серверов осуществляется командой *git remote*. Она дает список коротких имен для всех указанных вами областей удаленной работы. Если репозиторий был клонирован, вы должны увидеть по крайней мере источник, то есть имя, которое Git по умолчанию присваивает клонируемому серверу.

Параметр *-v* позволяет увидеть URL-адреса, которые Git хранит для сокращенного имени, используемого при чтении из данного удаленного репозитория и при записи в него. Если репозиториев несколько, они выводятся списком. 

## Извлечение данных из удаленных репозиториев 

Извлечение данных из удаленных проектов выполняется такой командой: 

    git fetch [имя удаленного репозитория] 

Эта команда связывается с удаленным проектом и извлекает оттуда все пока отсутствующие у вас данные. После этого у вас должны появиться ссылки на все ветки удаленного проекта, которые можно подвергнуть слиянию или просмотреть. При клонировании данная команда автоматически добавляет удаленный репозиторий под именем «origin». 

Соответственно команда *git fetch origin* извлекает все, что появилось на этом сервере после его клонирования (или после момента последнего извлечения информации). Важно понимать, что команда *git fetch* помещает все данные в ваш локальный репозиторий, — она не выполняет автоматическое слияние с ветками, с которыми вы работаете в данный момент, и вообще никак не затрагивает эти ветки. Слияние вы выполните вручную, как только в этом возникнет необходимость. 

По умолчанию команда 
    
    git clone 
    
автоматически настраивает вашу локальную ветку *master* на слежение за удаленной веткой master (она может иметь и другое имя) на сервере, с которого вы выполняли клониро вание. 

В общем случае команда 
    
    git pull 

извлекает данные с сервера, который вы клонировали, и автоматически пытается слить их с вашим текущим рабочим кодом.

## Отправка данных в удаленный репозиторий 

Чтобы поделиться результатами своего труда, их нужно отправить в репозиторий. Это делается простой командой 

    git push [имя удаленного сервера] [ветка]. 
    
Для отправки ветки *master* на сервер *origin* следует написать: 

     git push origin master

Команда сработает только при условии, что клонирование осуществлялось с сервера, где у вас есть доступ на запись, и за это время никто не отправлял туда свои данные. Если вы выполнили клонирование одновременно с другим пользователем и он уже отправил результаты своей работы на сервер, ваша попытка отправки данных окончится неудачей. Вам сначала нужно скачать все добавленное этим пользователем и встроить это в свои данные, и только после этого появится возможность воспользоваться командой *push*. 

## Удаление и переименование  удаленных репозиториев 

Переименование ссылок осуществляется командой 

    git remote rename

 меняющей сокращенные имена удаленных репозиториев. Эта команда умеет менять и имена удаленных веток. 

 Если по какой-то причине вы хотите удалить ссылку на удаленный репозиторий  (например, вы поменяли сервер, больше не используете конкретное зеркало или участник проекта перестал вносить в него вклад), используйте команду 
 
    git remote rm